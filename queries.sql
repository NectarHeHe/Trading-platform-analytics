select 
concat(e.first_name, ' ', e.last_name) as employees, 
sum(quantity) as income
from sales s 
right join employees e 
on s.sales_person_id = e.employee_id
group by employees
order by income desc nulls last 
limit 10;

/* Запрос обращается к основной таблице продаж
 * к которой присоединяется таблица продавцов
 * в задании нужно вывести топ 10 работников с самыми высокими продажами
 * для этого мы выводим сконкатенированные имя и фамилию работника и сумму его продаж за все время
 * группируемся по сотрудникам чтобы избежать повторений и вывести верную сумму продаж
 * так же я обработал NULL значение, хотя в этом не было необходимости, тк в топ 10 бы этот работник не попал
 * сортируемся по инкаму, чтобы первыми были сотрудники с самой высокой суммой выручки 
 * устанавливаем лимит в 10 сотрудников с самой высокой суммой выручки 
 */

select 
	concat(e.first_name, ' ', e.last_name) as employees, 
	coalesce (to_char(sale_date,'Day'),'no data') as day_of_week,
	coalesce (sum(quantity),0) as income
from 
	sales s 
right join 
	employees e 
	on s.sales_person_id = e.employee_id
group by 
	employees, 
	day_of_week,
	sale_date 
order by 
	sale_date, 
	employees;

/*
 * Запрос обращается к основной таблице продаж
 * к которой присоединяется таблица продавцов
 * в задании нужно вывести продавцов, сумма выручки которых ниже средней
 * для этого мы выводим сконкатенированные имя и фамилию работника, сумму его продаж за все время
 * здесь мы обрабатываем NULL уже не просто так, этот работник не сделал ни одной продажи, а значит и выручка = 0
 * группируемся по сотрудникам, чтобы избежать повторений и вывести верную сумму продаж
 * оборачиваем таблицу в WITH для того, чтобы использовать агрегированные значения инкама 
 * делаем подзапрос среднего с округлением, чтобы расчиталось общее среднее, а не среднее для каждого сотрудника
 * группируемся, тк HAVINGу нужна группирока, а where мы использовать не можем, тк низя))
 * 
 */

select 
	concat(e.first_name, ' ', e.last_name) as employees, 
	coalesce (to_char(sale_date,'Day'),'no data') as day_of_week,
	coalesce (sum(quantity),0) as income
from 
	sales s 
right join 
	employees e 
	on s.sales_person_id = e.employee_id
group by 
	employees, 
	day_of_week,
	sale_date 
order by 
	sale_date, 
	employees;


/* 
 * Запрос обращается к основной таблице продаж
 * к которой присоединяется таблица продавцов
 * по заданию нужен отчет с данными по выручке по каждому продавцу и дню недели
 * для этого мы выводим сконкатенированные имя и фамилию работника, день недели и сумму его продаж в этот день недели
 * не забываем обработать значение работника, который сделал 0 продаж
 * группируемся для получения правильных значений без повторов и так же по дате продаж, 
 * чтобы выставить по порядку значения дней недели
 * сортируемся по дню продажи и по сотрудникам
 */

	


